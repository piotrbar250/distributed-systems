<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="F. Plata, K. Iwanicki, M. Banaszek, W.
Ciszewski" />
  <title>Distributed Systems Large Assignment 2</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  <style type="text/css">
body
{
font-family: Helvetica, sans;
background-color: #f0f0f0;
font-size: 12pt;
color: black;
text-decoration: none;
font-weight: normal;
}
section.content {
width: 19cm;
font-size: 12pt;
text-align: justify;
margin-left: auto;
margin-right: auto;
margin-top: 20pt;
background-color: white;
padding: 20pt;
}
h1
{
font-size: xx-large;
text-decoration: none;
font-weight: bold;
text-align: center;
}
h2
{
font-size: xx-large;
text-decoration: none;
font-weight: bold;
text-align: left;
border-bottom: 1px solid #808080;
}
h3
{
font-size: x-large;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h1 + h3 {
text-align: center;
}
h4
{
font-size: large;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h5
{
font-size: medium;
text-decoration: none;
font-weight: bold;
text-align: left;
}
h6
{
font-size: medium;
text-decoration: none;
font-weight: normal;
text-align: left;
}
table
{
border-width: 1px;
border-spacing: 0px;
border-style: solid;
border-color: #808080;
border-collapse: collapse;
font-family: Times, serif;
font-size: 12pt;
color: black;
text-decoration: none;
font-weight: normal;
background-color: white;
}
td
{
border-width: 1px;
border-style: solid;
border-color: #808080;
padding: 3pt;
background-color: white;
}
th
{
border-width: 1px;
border-style: solid;
border-color: #808080;
padding: 3pt;
font-weight: bold;
background-color: #f0f0f0;
}
a:link {
color: blue;
text-decoration: none;
font-weight: normal;
}
a:visited {
color: blue;
text-decoration: none;
font-weight: normal;
}
a:hover {
text-decoration: underline;
font-weight: normal;
}
pre.sourceCode {
font-size: 90%;
}
</style>
</head>
<body>
<section id="distributed-systems-large-assignment-2" class="content">
<h1>Distributed Systems Large Assignment 2</h1>
<h3 id="atomic-disk-drive">Atomic Disk Drive</h3>
<p>Your task is to implement a distributed block device that stores data
in distributed registers. The solution shall take the form of a Rust
library. A template, public tests, and additional files are provided in
<a href="./dsassignment2.tgz">this package</a>.</p>
<p>Although you will be using the module <code>System</code> from the
first Large Assignment in some later assignments, we <strong>do
NOT</strong> recommend using it for this assignment!</p>
<h3 id="background">Background</h3>
<p>On UNIX-like operating systems, a <strong>block device</strong> is,
simplifying, a device that serves random-access reads and writes of data
in portions called <strong>blocks</strong>. Arguably, the most common
types of block devices are disk drives (e.g., HDD and SSD). However, the
term is also applied to various abstractions that implement the
interface of the block device (and thus, from a user’s perspective, can
be used like any other block device), but do not store data on physical
devices. For instance, <strong>Atomic Disc Drive</strong>, which stores
data in a <strong>distributed register</strong>.</p>
<p>A distributed register consists of multiple
<strong>processes</strong> (entities of the distributed register, not
operating system processes) running in user space, possibly on multiple
physical (or virtual) machines. A Linux block device driver communicates
with the processes using TCP. The processes themselves communicate using
TCP too. The processes can crash and recover at any time. A number of
the processes is fixed before the system is run, and every process is
given its own directory where it can store its internal files.</p>
<p>The smallest physical unit inside a block device is called a
<strong>sector</strong>. Its size is specific to each device. The size
of a block is in turn always a multiple of the size of the sector. In
the Atomic Disk Drive, every sector is a separate atomic value called
<strong>register</strong> (and thus it is said that the system supports
a set of atomic values/registers). The sector has a size of 4096
bytes.</p>
<p>As follows from the above description, a complete Atomic Disk Drive
consists of two parts: a Linux block device driver, and a user-space
library implementing the distributed register. The Linux block device
driver is provided in the package (see <a href="./linux_driver.html">instructions</a> on how to use it), and you
can use it to test your solution. Your task is to implement in Rust the
user-space part as a distributed system.</p>
<h3 id="distributed-register">Distributed register</h3>
<p>Your implementation of the distributed register shall be based on an
algorithm named <strong>(N, N)-AtomicRegister</strong>.</p>
<h4 id="n-n-atomicregister">(N, N)-AtomicRegister</h4>
<p>There is a fixed number of instances of the AtomicRegister module,
<code>N</code>, and all instances know about each other. Crashes of
individual instances can happen. Every instance can initiate both read
and write operations (thus the <code>(N, N)</code> in the name of the
algorithm). It is assumed that the system is able to progress on
operations as long as at least a majority of the instances are working
correctly.</p>
<p>The core algorithm, based on the lecture and modified to suit the
crash-recovery model, is as follows (the definition of stubborn links
remains the same as in the crash-stop model):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb1-1"><a href="#cb1-1"></a>Implements:</span>
<span id="cb1-2"><a href="#cb1-2"></a>    (N,N)-AtomicRegister instance nnar.</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>Uses:</span>
<span id="cb1-5"><a href="#cb1-5"></a>    StubbornBestEffortBroadcast, instance sbeb;</span>
<span id="cb1-6"><a href="#cb1-6"></a>    StubbornLinks, instance sl;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>upon event &lt; nnar, Init &gt; do</span>
<span id="cb1-9"><a href="#cb1-9"></a>    (ts, wr, val) := (0, 0, _);</span>
<span id="cb1-10"><a href="#cb1-10"></a>    readlist := [ _ ] `of length` N;</span>
<span id="cb1-11"><a href="#cb1-11"></a>    acklist := [ _ ] `of length` N;</span>
<span id="cb1-12"><a href="#cb1-12"></a>    reading := FALSE;</span>
<span id="cb1-13"><a href="#cb1-13"></a>    writing := FALSE;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    writeval := _;</span>
<span id="cb1-15"><a href="#cb1-15"></a>    readval := _;</span>
<span id="cb1-16"><a href="#cb1-16"></a>    write_phase := FALSE;</span>
<span id="cb1-17"><a href="#cb1-17"></a>    store(wr, ts, val);</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>upon event &lt; nnar, Recovery &gt; do</span>
<span id="cb1-20"><a href="#cb1-20"></a>    retrieve(wr, ts, val);</span>
<span id="cb1-21"><a href="#cb1-21"></a>    readlist := [ _ ] `of length` N;</span>
<span id="cb1-22"><a href="#cb1-22"></a>    acklist := [ _ ]  `of length` N;</span>
<span id="cb1-23"><a href="#cb1-23"></a>    reading := FALSE;</span>
<span id="cb1-24"><a href="#cb1-24"></a>    readval := _;</span>
<span id="cb1-25"><a href="#cb1-25"></a>    write_phase := FALSE;</span>
<span id="cb1-26"><a href="#cb1-26"></a>    writing := FALSE;</span>
<span id="cb1-27"><a href="#cb1-27"></a>    writeval := _;</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a>upon event &lt; nnar, Read &gt; do</span>
<span id="cb1-30"><a href="#cb1-30"></a>    op_id := generate_unique_id();</span>
<span id="cb1-31"><a href="#cb1-31"></a>    readlist := [ _ ] `of length` N;</span>
<span id="cb1-32"><a href="#cb1-32"></a>    acklist := [ _ ] `of length` N;</span>
<span id="cb1-33"><a href="#cb1-33"></a>    reading := TRUE;</span>
<span id="cb1-34"><a href="#cb1-34"></a>    trigger &lt; sbeb, Broadcast | [READ_PROC, op_id] &gt;;</span>
<span id="cb1-35"><a href="#cb1-35"></a></span>
<span id="cb1-36"><a href="#cb1-36"></a>upon event &lt; sbeb, Deliver | p [READ_PROC, id] &gt; do</span>
<span id="cb1-37"><a href="#cb1-37"></a>    trigger &lt; sl, Send | p, [VALUE, id, ts, wr, val] &gt;;</span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a>upon event &lt;sl, Deliver | q, [VALUE, id, ts&#39;, wr&#39;, v&#39;] &gt; such that id == op_id and !write_phase do</span>
<span id="cb1-40"><a href="#cb1-40"></a>    readlist[q] := (ts&#39;, wr&#39;, v&#39;);</span>
<span id="cb1-41"><a href="#cb1-41"></a>    if #(readlist) &gt; N / 2 and (reading or writing) then</span>
<span id="cb1-42"><a href="#cb1-42"></a>        readlist[self] := (ts, wr, val);</span>
<span id="cb1-43"><a href="#cb1-43"></a>        (maxts, rr, readval) := highest(readlist);</span>
<span id="cb1-44"><a href="#cb1-44"></a>        readlist := [ _ ] `of length` N;</span>
<span id="cb1-45"><a href="#cb1-45"></a>        acklist := [ _ ] `of length` N;</span>
<span id="cb1-46"><a href="#cb1-46"></a>        write_phase := TRUE;</span>
<span id="cb1-47"><a href="#cb1-47"></a>        if reading = TRUE then</span>
<span id="cb1-48"><a href="#cb1-48"></a>            trigger &lt; sbeb, Broadcast | [WRITE_PROC, op_id, maxts, rr, readval] &gt;;</span>
<span id="cb1-49"><a href="#cb1-49"></a>        else</span>
<span id="cb1-50"><a href="#cb1-50"></a>            (ts, wr, val) := (maxts + 1, rank(self), writeval);</span>
<span id="cb1-51"><a href="#cb1-51"></a>            store(ts, wr, val);</span>
<span id="cb1-52"><a href="#cb1-52"></a>            trigger &lt; sbeb, Broadcast | [WRITE_PROC, op_id, maxts + 1, rank(self), writeval] &gt;;</span>
<span id="cb1-53"><a href="#cb1-53"></a></span>
<span id="cb1-54"><a href="#cb1-54"></a>upon event &lt; nnar, Write | v &gt; do</span>
<span id="cb1-55"><a href="#cb1-55"></a>    op_id := generate_unique_id();</span>
<span id="cb1-56"><a href="#cb1-56"></a>    writeval := v;</span>
<span id="cb1-57"><a href="#cb1-57"></a>    acklist := [ _ ] `of length` N;</span>
<span id="cb1-58"><a href="#cb1-58"></a>    readlist := [ _ ] `of length` N;</span>
<span id="cb1-59"><a href="#cb1-59"></a>    writing := TRUE;</span>
<span id="cb1-60"><a href="#cb1-60"></a>    trigger &lt; sbeb, Broadcast | [READ_PROC, op_id] &gt;;</span>
<span id="cb1-61"><a href="#cb1-61"></a></span>
<span id="cb1-62"><a href="#cb1-62"></a>upon event &lt; sbeb, Deliver | p, [WRITE_PROC, id, ts&#39;, wr&#39;, v&#39;] &gt; do</span>
<span id="cb1-63"><a href="#cb1-63"></a>    if (ts&#39;, wr&#39;) &gt; (ts, wr) then</span>
<span id="cb1-64"><a href="#cb1-64"></a>        (ts, wr, val) := (ts&#39;, wr&#39;, v&#39;);</span>
<span id="cb1-65"><a href="#cb1-65"></a>        store(ts, wr, val);</span>
<span id="cb1-66"><a href="#cb1-66"></a>    trigger &lt; sl, Send | p, [ACK, id] &gt;;</span>
<span id="cb1-67"><a href="#cb1-67"></a></span>
<span id="cb1-68"><a href="#cb1-68"></a>upon event &lt; sl, Deliver | q, [ACK, id] &gt; such that id == op_id and write_phase do</span>
<span id="cb1-69"><a href="#cb1-69"></a>    acklist[q] := Ack;</span>
<span id="cb1-70"><a href="#cb1-70"></a>    if #(acklist) &gt; N / 2 and (reading or writing) then</span>
<span id="cb1-71"><a href="#cb1-71"></a>        acklist := [ _ ] `of length` N;</span>
<span id="cb1-72"><a href="#cb1-72"></a>        write_phase := FALSE;</span>
<span id="cb1-73"><a href="#cb1-73"></a>        if reading = TRUE then</span>
<span id="cb1-74"><a href="#cb1-74"></a>            reading := FALSE;</span>
<span id="cb1-75"><a href="#cb1-75"></a>            trigger &lt; nnar, ReadReturn | readval &gt;;</span>
<span id="cb1-76"><a href="#cb1-76"></a>        else</span>
<span id="cb1-77"><a href="#cb1-77"></a>            writing := FALSE;</span>
<span id="cb1-78"><a href="#cb1-78"></a>            trigger &lt; nnar, WriteReturn &gt;;</span></code></pre></div>
<p>The <code>rank(*)</code> returns a rank of an instance, which is a
static number assigned to an instance. The <code>highest(*)</code>
returns the largest value ordered lexicographically by <code>(timestamp, rank)</code>.</p>
<p>Your solution will not be receiving special <code>Recovery</code> or
<code>Init</code> events. Each time it starts, it shall try to recover
from the persistent storage (during the initial run, the persistent
storage will be empty). Crashes are expected to happen at any point,
your solution shall work despite them. The algorithm presented above is
only a pseudocode, so we suggest understanding ideas behind it.</p>
<h4 id="linearization">Linearization</h4>
<p>Usually, components of a distributed system do not share a common
clock. Atomic Disk Device does not have one too, and thus the events can
happen at different rates and in various orders in every process.
However, the atomic register enforces constraints between events on
processes, and thereby it makes it possible to put all read and write
operations on a single timeline, and to mark the start and end of each
operation. Every read returns the most recently written value. If an
operation <code>o</code> happens before operation <code>o&#39;</code> when
the system is processing messages, then <code>o</code> must appear
before <code>o&#39;</code> on such a common timeline. This is called
<em>linearization</em>.</p>
<p>To sum up, from a perspective of a single client (e.g., the Linux
driver) communicating through a single atomic register process, there is
a single sequence of read and write events. The client would not be able
to distinguish between the distributed register and some single device
if it was performing the operations instead.</p>
<h4 id="performance">Performance</h4>
<p>The atomic register process, as presented above, can only progress
with one read or write operation at a time. However, this restriction
applies only to a single value. Therefore, to improve the performance of
Atomic Disk Device, one can run multiple instances of the atomic
register algorithm, each progressing on a different sector. Your
solutions are expected to provide this kind of concurrency and be able
to process many sectors at once.</p>
<h3 id="solution-specification">Solution specification</h3>
<p>Your solution shall take the form of a cargo library crate. Its main
function is <code>run_register_process()</code> from the
<code>solution/src/lib.rs</code> file, which shall run a new process of
the distributed register. This function will be used by a simple
wrapper—program to run your solution. The process will be passed all
necessary information (e.g., addresses for TCP communication, directory
for persistent storage, HMAC keys, etc.) via the
<code>Configuration</code> struct (<code>solution/src/domain.rs</code>)
provided as an argument to the function.</p>
<p>The solution shall be asynchronous. It will be run using Tokio.</p>
<h4 id="tcp-communication">TCP communication</h4>
<p>Components of Atomic Disk Device shall communicate using TCP. The
communication shall work as follows:</p>
<h5 id="serialization-and-deserialization">Serialization and
deserialization</h5>
<p>All exchanged messages are in form:</p>
<ul>
<li>Message size: (payload + HMAC) in bytes (8 bytes, big-endian),</li>
<li>Payload: structure(s) serialized in <a href="https://docs.rs/bincode/latest/bincode/">bincode</a> format with
big-endian and fixed integer size encoding,</li>
<li>HMAC tag: <code>hmac(sh256)</code> of the payload (32 bytes).</li>
</ul>
<p>Your solution shall provide two methods:
<code>deserialize_register_command()</code> and
<code>serialize_register_command()</code>. They convert bytes to a
<code>RegisterCommand</code> object and in the other direction,
respectively. Serialization shall complete successfully when there are
no serialization errors and no errors when writing to the provided
reference that implements <code>AsyncWrite</code>. If errors occur, the
serializing function shall return them wrapped accordingly.</p>
<p>Deserialization shall return a pair
<code>(message, hmac_valid)</code> when a valid message is encountered.
An error shall be returned if an error occurs when reading from the
provided <code>AsyncRead</code> reference or during deserialization of
the payload. In case of receiving incorrect message, the connection
should be dropped.</p>
<h5 id="client-to-process-communication">Client-to-process
communication</h5>
<p>In the following description, we name a <em>client</em> any
application communicating with the distributed register using TCP. The
target client is the Linux device driver, which is a part of Atomic Disk
Drive. However, other clients will be also used when evaluating your
solution (for instance, when unit testing).</p>
<p>Every process of the system can be contacted by a client. Clients
connect using TCP, and send <code>domain::RegisterCommand::Client</code>
(see <code>solution/src/domain.rs</code>) commands. Your process must
issue replies after a particular command is safely completed by the
distributed register. Client can use the request identifier for internal
identification of messages. Example command for write sector:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">RegisterCommand::</span>Client(ClientRegisterCommand <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    header<span class="op">:</span> ClientCommandHeader <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>        request_identifier<span class="op">:</span> <span class="dv">42</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>        sector_idx<span class="op">:</span> <span class="dv">12</span><span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="op">},</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    content<span class="op">:</span> <span class="pp">ClientRegisterCommandContent::</span><span class="bu">Write</span> <span class="op">{</span> <span class="co">// for read use ClientRegisterCommandContent::Read</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>        data<span class="op">:</span> SectorVec(<span class="pp">vec!</span>[<span class="dv">3</span><span class="op">;</span> <span class="dv">4096</span>])<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="op">},</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="op">}</span>)</span></code></pre></div>
<p>After the system completes the operation, it shall reply with a
<code>domain::ClientCommandResponse</code>, for example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1"></a>ClientCommandResponse <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    status<span class="op">:</span> <span class="pp">StatusCode::</span><span class="cn">Ok</span><span class="op">,</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    request_identifier<span class="op">:</span> <span class="dv">42</span><span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    op_return<span class="op">:</span> <span class="pp">OperationReturn::</span><span class="bu">Write</span><span class="op">,</span> <span class="co">// for read: OperationReturn::Read</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="op">}</span></span></code></pre></div>
<p>Possible status codes are listed in <code>StatusCode</code>
(<code>solution/src/domain.rs</code>), and it is documented there when
each code is expected.</p>
<p>The response content for a successful write is empty, for a
successful read it is 4096 bytes read from the system. If a command
fails for any reason, the corresponding response shall have an empty
content.</p>
<p>Requests with an invalid HMAC tag shall be discarded with an
appropriate status code returned. A HMAC key for client commands and
responses is provided in <code>Configuration.hmac_client_key</code>
(<code>solution/src/domain.rs</code>). When evaluating your solution,
the key will be provided to the clients by a testing framework.</p>
<p>You can assume that a client will not send multiple commands with the
same sector index at the same time. In other words, if a client sends a
command regarding some sector, it will wait for the response before
sending another command regarding this sector. However, there can be
multiple clients, and different clients can each send a command with the
same sector index at the same time.</p>
<p>Operations submitted by clients can be executed in an arbitrary
order. The system shall start sending a response when a command is
completed by the register.</p>
<p>Since one atomic register can execute only one operation at a time
(for a given sector), the operations shall be queued. We suggest using a
TCP buffer itself as the queue.</p>
<h5 id="process-to-process-communication">Process-to-process
communication</h5>
<p>Internal messages (i.e., messages sent between processes) shall use
<code>domain::RegisterCommand::System</code>.</p>
<p>These internal messages shall be signed with a different HMAC key
than messages to/from clients. The key is provided in
<code>Configuration.hmac_system_key</code>
(<code>solution/src/domain.rs</code>). The process rank is the rank of a
process that sends the command. The message types and their content are
as follows:</p>
<ol type="1">
<li><p><code>SystemRegisterCommandContent::ReadProc</code>: no
content</p></li>
<li><p><code>SystemRegisterCommandContent::Value</code>: contains
timestamp, rank of a process, which delivered the last write, and the
sector data (4096 bytes).</p></li>
<li><p><code>SystemRegisterCommandContent::WriteProc</code>: contains
timestamp, rank of a process, which delivered the last write, and the
sector data (4096 bytes).</p></li>
<li><p><code>SystemRegisterCommandContent::Ack</code>: no
content</p></li>
</ol>
<p>Moreover, you are allowed to create acknowledgment responses to the
internal messages. They can contain: - the UUID and type of a message
that is being acknowledged, - rank of a process, which sends the
response (i.e., acknowledges the message).</p>
<p>The acknowledgment responses shall be signed with the
<code>Configuration.hmac_system_key</code> HMAC key too.</p>
<h5 id="other-requirements">Other requirements</h5>
<p>We expect that within 300 milliseconds after calling
<code>run_register_process()</code> a TCP socket will be bound. We
suggest the function binds to the appropriate socket before executing
other actions.</p>
<p>Your internal TCP client is not allowed to lose any messages, even
when a target process crashes and the TCP connection gets broken.
Remember that the (N,N)-AtomicRegister algorithm relies on stubborn
links, which send messages forever (unless the sender crashes). This
behavior models retransmissions. In an actual implementation, messages
should be retransmitted (with some delay interval) until the sender
learns that further retransmissions are guaranteed to have no influence
on the system’s progress.</p>
<p>You are allowed to use custom messages, for instance, for debugging
purposes.</p>
<p>Messages sent by a process to itself should skip TCP, serialization,
deserialization, HMAC preparation and validation phases to improve the
performance.</p>
<h4 id="internal-interfaces">Internal interfaces</h4>
<p>Aside from integration tests, which evaluate your solution as a
whole, your solution will also be evaluated with unit tests. To this
end, the template splits the implementation of the distributed register
into multiple parts and defines their interfaces. Most of the interfaces
are asynchronous, since running the register will result in multiple IO
tasks, and cooperative multitasking seems to be notably profitable in
such application.</p>
<p>In the package, we provide a diagram (<code>atdd.svg</code>)
presenting how Atomic Disk Device might be implemented. Every process of
the distributed register is wrapped in a Linux process. Tokio is used as
the executor system. The Linux block device driver sends commands to
processes over TCP. Processes communicate with one another using
internal messages, and then complete the commands and return responses
over TCP back to the driver. Every process of the distributed register
has multiple copies of the atomic register code, to support concurrent
writes/reads on distinct sectors. The copies share a component, which
handles communication (<code>RegisterClient</code>), and a component,
which handles storing sectors data.</p>
<p>Your solution shall implement the following interfaces (they are
defined in <code>solution/src/lib.rs</code>):</p>
<h5 id="atomicregister">AtomicRegister</h5>
<p><code>AtomicRegister</code> provides functionality required of an
instance of the atomic register algorithm. It is created by calling
<code>build_atomic_register()</code> (<code>solution/src/lib.rs</code>).
All its methods shall follow the atomic register algorithm presented
above. When implementing <code>AtomicRegister</code>, you can assume
that <code>RegisterClient</code> passed to the function implements
<code>StubbornLink</code> required by the algorithm.</p>
<p>Every sector is logically a separate atomic register. However, you
should not keep <code>Configuration.public.n_sectors</code>
<code>AtomicRegister</code> objects in memory; instead, you should
dynamically create and delete them to limit the memory usage (see also
the Technical Requirements section).</p>
<h5 id="sectorsmanager">SectorsManager</h5>
<p><code>SectorsManager</code> facilitates storing sectors data in the
filesystem directory. Sector data shall be stored together with
necessary basic information, such as the logical timestamp and the write
rank (see the pseudocode of the atomic register algorithm).</p>
<p>Sectors are numbered from <code>0</code> inclusive to
<code>Configuration.public.n_sectors</code>
(<code>solution/src/domain.rs</code>) exclusive. You can assume that
<code>Configuration.public.n_sectors</code> will not exceed
<code>2^21</code>.</p>
<p>If a sector was never written, we assume that both the logical
timestamp and the write rank are <code>0</code>, and that
it contains 4096 zero bytes.</p>
<p>No particular storage scheme is required, it must just provide atomic
operations. No caching is necessary.</p>
<p>The <code>build_sectors_manager()</code> function
(<code>solution/src/lib.rs</code>) shall create an instance of
<code>SectorManager</code> for, among others, unit testing. You can
assume that the unit tests will not perform concurrent operations on the
same sector, even though the trait is marked as <em>Sync</em>.</p>
<p><code>SectorsManager</code> is a specialized persistent storage for
sector data and metadata. Such specialization allows for optimizing disk
usage (see also the Technical Requirements section), and possibly
performance.</p>
<p>A directory for <code>SectorsManager</code> is provided in
<code>Configuration.public.storage_dir</code>
(<code>solution/src/domain.rs</code>).</p>
<h5 id="registerclient">RegisterClient</h5>
<p><code>RegisterClient</code> manages TCP communication between
processes of the distributed register. An instance is passed to
instances of <code>AtomicRegister</code> to allow them communicating
with each other.</p>
<p>This trait is introduced mainly for the purpose of unit testing.</p>
<p>When a process sends a message to itself, it is suggested to transfer
the message in some manner more directly than through TCP to increase
the performance.</p>
<h4 id="technical-requirements">Technical requirements</h4>
<p>Your solution will be tested with the latest stable Rust version.</p>
<h5 id="interface">Interface</h5>
<p>You must not modify the public interface of the library. You can,
however, implement more derivable traits for public types via the
<code>derive</code> attribute.</p>
<h5 id="dependencies">Dependencies</h5>
<p>You can use only crates listed in <code>solution/Cargo.toml</code>
for main dependencies. During grading, the original
<code>Cargo.toml</code> will be used, and if you submit one, it will be
discarded. In particular, it means that while writing the solution, you
may put anything you want in the <code>[dev-dependencies]</code>
section. However, you should not use <code>[build-dependencies]</code>
or a build script, but you can specify any number of binaries in your
local <code>Cargo.toml</code>. If you need any other crate, ask on
Moodle for permission. If a permit is granted, the template will change
and every student is allowed to use it.</p>
<p>Using asynchronous libraries makes it easy to scale your solution to
the number of available cores, and wait for completions of hundreds of
concurrent IO tasks. This is necessary to reach an acceptable
performance.</p>
<h5 id="storage">Storage</h5>
<p>Because crashes are to be expected, the <code>Configuration</code>
struct specifies a directory for an exclusive use by a process. You are
allowed to create subdirectories within the directory. You are not
allowed to touch any other directory.</p>
<p>There is a limit on the number of open file descriptors: 1024. We
suggest utilizing it for maximum concurrency. You can assume that there
will not be more than 16 client connections.</p>
<p>You can assume that the local filesystem stores data in blocks of
4096 bytes, the same size as the sectors.</p>
<p>Your solution is allowed to use at most 10% more filesystem space
than the size of sectors, which have been written to. That is, if there
were writes to <code>n</code> distinct sectors, it is expected that the
total directory size does not exceed
<code>1.1 * n * 4096 + constant</code> bytes (with the constant being
reasonable). Temporary files used for ensuring atomicity do not count
towards this limit. However, they must be removed when they are no
longer necessary. In particular, this means when the system is not
handling any messages, the filesystem usage should be below the
limit.</p>
<p>Hint: to fulfill the above requirement, you can try storing sector
metadata in filenames. The recovery of <code>SectorsManager</code> can
have O(n) time complexity.</p>
<h5 id="memory">Memory</h5>
<p>Your solution can use memory linear in the number of sectors, which
have been written to. It should not use memory linear in the total
number of sectors.</p>
<h5 id="logging">Logging</h5>
<p>You are allowed to use logging as you wish, as long as your solution
does not produce a huge volume of messages at levels
<code>&gt;= INFO</code> when the system is operating correctly. All
logging must be done via the <code>log</code> crate.</p>
<h5 id="performance-1">Performance</h5>
<p>To receive the maximum number of points for performance, your
solution must be able to process at least 50 sectors per second when run
on the students machine with 4 system processes and 3 threads (used by
tokio runtime) per process. Remember that your solution will probably
run slower on students than on a lab computer!</p>
<h3 id="assignment-specification">Assignment specification</h3>
<p>You are given a subset of official tests (see
<code>public-tests/</code> in the package). Their intention is to make sure that the public interface of your
solution is correct, and to evaluate basic functionality.</p>
<h4 id="submitting-a-solution">Submitting a solution</h4>
<p>Your solution must be submitted as a single <code>.zip</code> file
with its name being your login at students (e.g.,
<code>ab123456.zip</code>). After unpacking the archive, a directory
path named <code>ab123456/solution/</code> must be created. In the
<code>solution</code> subdirectory there must be a Rust library crate
that implements the assignment. Project <code>public-tests</code> must
be able to be built and tested cleanly when placed next to the
<code>solution</code> directory.</p>
<h4 id="grading">Grading</h4>
<p>Your solution will be graded based on the results of automatic tests
and code inspection. The number of available and required points is
specified in the <a href="../../">Passing Rules</a> described at the
main website of the course. If your solution passes the public tests,
you will receive at least the required number of points. Solutions,
which will not actually implement a distributed system (e.g., they will
keep all data in RAM only, execute commands on a single node, etc.) will
be rejected.</p>
<hr />
<p>Authors: F. Plata, K. Iwanicki, M. Banaszek, W. Ciszewski, P.
Żuk.</p>
</section>
</body>
</html>